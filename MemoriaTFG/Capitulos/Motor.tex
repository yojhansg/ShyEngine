%---------------------------------------------------------------------
%
%                          Motor
%
%---------------------------------------------------------------------

\chapter{Motor}

\section{Cómo funciona y cómo está dividio}

El motor esta dividio en diez proyectos de tecnología y cada uno cumple una función específica.

\medskip

A continuación se entrará en detalle sobre la función y detalles de implementación de cada proyecto y de las librerías asociadas al mismo, si las tiene.


% ----------------------------------------------- UTILIDADES -------------------------------------------------

\subsection{Utilidades}

El objetivo de este proyecto es implementar código común que pueden necesitar el resto  de proyectos evitando así la duplicación de código innecesaria.
Contiene clases tanto orientadas a guardar información como a implementar lógica y funcionalidad.

\medskip

Entre estas clases destacan las siguientes:

\begin{itemize}

    \item \texttt{Vector2D}: Representa un vector bidimensional, contiene información de dos componentes e implementa muchas de sus operaciones básicas. 
    
    \item \texttt{Random}: Contiene métodos estáticos útiles para calcular aleatoriedad entre números enteros, números reales, ángulos, y colores. 
    
    \item \texttt{Color}: Representa un color de tres canales (Red, Green, Blue) además de métodos con algo de funcionalidad como \texttt{Lerp}, que calcula
    un color intermedio entre otros dos dados y un porcentaje que representa la influencia que tendrá cada color en el color resultante. 
    
    \item \texttt{EngineTime}: Por un lado, contiene información sobre el tiempo entre fotogramas del motor, tiempo entre pasos físicos, tiempo transcurrido 
    desde el inicio del programa y número de fotogramas hasta el momento.
    
    \item \texttt{Singleton}: Una plantilla para crear instancias estáticas a través de herencia. Es decir, en caso de querer convertir una clases en un 
    \texttt{Singleton}, muy útiles para managers, simplemente hay que heredar de esta clase  para conseguirlo. 
    
\end{itemize}




% ----------------------------------------------- RECURSOS -------------------------------------------------

\subsection{Recursos}

El objetivo de este proyecto es proporcionar un contenedor de recursos en el que se van a guardar todos los recursos del videojuego. En concreto, el tipo de
recursos que se pueden guardar son fuentes de texto, imágenes, efectos de sonido y música.

\medskip

El manager de recursos contiene un mapa por cada tipo de recurso donde la clave es la ruta del archivo y el valor un puntero a un objeto del tipo del recurso
(\texttt{Texture*}, \texttt{Font*}, \texttt{Sound*}, \texttt{Music*}). El hecho de utilizar un mapa se debe a la complejidad constante de acceder a los
recursos una vez creados.

\medskip

Esto es importante porque uno de los objetivos del manager de recursos es reutilizar los recursos creados para solo tener cargada una copia de cada recurso en
memoria. Por ello, a la hora de añadir un nuevo recurso al manager, primero comprueba si ya lo contiene y en ese caso, lo devuelve, en caso contrario, lo crea.

\medskip

Ya que la clave en los mapas es la ruta del archivo, los recursos pueden duplicarse en caso de tener el mismo archivo en diferentes directorios. El manager no
contempla ese escenario ya que realmente el archivo también esta duplicado y es responsabilidad del desarrollador ordenar sus archivos de assets.




% ----------------------------------------------- SONIDO -------------------------------------------------

\subsection{Sonido}

El objetivo de este proyecto es construir un envoltorio sobre la librería de audio \texttt{SDL\_Mixer} para poder implementar posteriormente los componentes
\texttt{MusicEmitter} y \texttt{SoundEmitter}.

\medskip

Para un mejor entendimiento de la implementación es necesario saber que \texttt{SDL\_Mixer} diferencia entre efectos de sonido o sonidos cortos en general (WAV, MP3)
y música de fondo (WAV, MP3, OGG).

\medskip

Para la música, la librería solo cuenta con un canal de reproducción por lo que es algo limitado pero simple a la vez ya que no hay que lidiar con número de canales, 
al contrario que con los efectos de sonido.

\medskip

Este proyecto cuenta con tres clases:

\begin{itemize}

\item \texttt{SoundEffect}: Representa un efecto de sonido. Contiene la información de un MixChunk de SDL\_Mixer y un identificador usado posteriormente por el componente
\texttt{SoundEmitter}.

\item \texttt{MusicEffect}: Representa un sonido de música de fondo. Contiene la información de un \texttt{MixMusic} de \texttt{SDL\_Mixer} y un identificador usado 
posteriormente por el componente \texttt{MusicEmitter}.

Estas dos clases representan también los recursos que se usan para música y sonidos en el 
manager de recursos.

\item \texttt{SoundManager}: Manager \texttt{Singleton} encargado de implementar el envoltorio de las funciones principales de \texttt{SDL\_Mixer} para reproducir, parar,
y detener sonidos, entre otros. Tiene dos métodos destinados al usuario para el modificar el volumen general y cambiar el número de canales disponibles para la reproducción
de efectos de sonidos.

\end{itemize}


% ----------------------------------------------- INPUT -------------------------------------------------

\subsection{Input}

Este proyecto tiene como objetivo implementar un manager, también \texttt{Singleton}, que contendrá la información del estado de las teclas/botones de los dispositivos de
entrada. En concreto, cuenta con soporte para teclado, ratón y mando.

\medskip

En el manager, las teclas/botones pueden pasar por diferentes estados los cuales se establecen al recibir determinados
eventos de SDL y se actualizan debidamente.

\medskip

Estos estados se dividen en:

\begin{enumerate} 
    \item \textit{Down}: Una tecla esta siendo pulsada. 
    \item \textit{Up}: Una tecla no esta siendo pulsada. 
    \item \textit{Pressed}: Una tecla acaba de ser pulsada. 
    \item \textit{Released}: Una tecla acaba de ser soltada. 
\end{enumerate} 

\begin{itemize} 

\item \textit{Teclado}: Guarda la información sobre la mayoría de teclas importantes de un teclado. Letras, números y teclas especiales. Para ello, el manager cuenta con tres
enumerados que contienen el nombre de cada una de las teclas para cada tipo.

\item \textit{Ratón}: Guarda la información de la posición del ratón, del estado del clic izquierdo, clic central (de la rueda), clic derecho y movimiento de la rueda.

\item \textit{Mando}: Cuenta con soporte para múltiples mandos y cada uno de ellos guarda la siguiente información:  

\begin{enumerate} 
    \item Nombre del mando.
    \item Estado de cada uno de los botones del mando.
    \item Información del movimiento de los triggers del mando.
    \item Información del movimiento de los joysticks del mando.
\end{enumerate}

El manager tiene sporte además para conexiones y desconexiones durante la ejecución. Debido a la posibilidad de tener varios mandos conectados el manager diferencia entre métodos
con identificador y métodos sin identificador. Los métodos con identificador reciben el identificador del mando del que se quiere consultar el estado y los métodos sin identificador
devuelven la información del estado del último mando que registró input. De esa manera, si se quiere desarrollar un singleplayer, el usuario no tendrá que preocuparse por la posibilidad
de múltiples mandos teniendo que indicar que identificador tiene su mando. 

\end{itemize}

Por último, el manager implementa métodos de lógica para el usuario como movimiento horizontal y vertical, salto o acción.



% ----------------------------------------------- CONSOLA -------------------------------------------------

\subsection{Consola}

Este proyecto contiene una sola clase Output con métodos estáticos que implementan funcionalidad relacionada con el mostrado de la salida estándar por la consola.

\medskip

Tiene métodos para imprimir por consola con los colores por defecto, imprimir una advertencia, con color amarillo e imprimir un error, con color rojo, entre otros.

\medskip

Además de ser útil para el desarrollo, sirve también para dar formato a los mensajes que aparecen por la consola del editor. Se utiliza una tubería o pipe para conectar la consola del motor
y la del editor. Esto se cuenta más en detalle en el apartado de editor.





% ----------------------------------------------- FISICAS -------------------------------------------------

\subsection{Físicas}

Este proyecto tiene como objetivo implementar un envoltorio sobre la librería de físicas Box2D para proporcionar una API sencilla para el usuario y para desarrollar los componentes de colisión
y movimiento físico necesarios.

\medskip

Antes de nada, al igual que con \texttt{SDL\_Mixer}, algunos conceptos sobre la librería: 

\begin{itemize}
    \item \textit{Mundo físico}: La librería tiene una clase b2World que representa un mundo físico donde se pueden crear cuerpos físicos. Esta clase tiene un método fundamental \texttt{Step()}, 
    al que se debe llamar para realizar un paso físico, lo que actualiza la simulación al avanzar el tiempo en un intervalo fijo, realiza cálculo de colisiones, resuelve restricciones y actualiza
    posiciones y velocidades. 

    \item \textit{Unidades}: Box2D trabaja con números de punto flotante y es necesario tener en cuenta alguna restricciones para que Box2D funcione correctamente. Estas restricciones han sido 
    ajustadas para funcionar bien con unidades de metros-kilogramos-segundos (MKS). En particular, Box2D ha sido ajustado para funcionar adecuadamente con formas en movimiento que tienen dimensiones
    entre 0.1 y 10 metros.

    \item \textit{Pixeles}: Es tentador usar pixeles como unidades para los tamaños, posiciones, fuerzas o velocidades pero desafortunadamente, esto llevaría a una simulación ineficiente y posiblemente
    a un comportamiento extraño. En la propia documentación de Box2D comentan que un objeto de 200 píxeles de longitud sería visto por Box2D como el tamaño de un edificio de 45 pisos.
\end{itemize}

Para resolver el problema de los pixeles, se usa un valor \textit{screenToWorldFactor} usado para convertir de pixeles a unidades físicas y viceversa. Por lo tanto, a la hora de crear cuerpos
físicos se convierte el tamaño en pixeles deseado por el usuario a unidades físicas utilizando ese factor de escala.

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}
    \item \textit{PhysicsManager}: Clase, \texttt{Singleton}, que contiene la funcionalidad necesariara para manejar el filtrado de colisiones e información sobre gravedad del mundo físico así como la
    matriz de colisiones y capas existentes.

    \medskip

    En cuanto al filtrado de colisiones, cada objeto físico tiene máscaras de bits donde guarda la información sobre en que capa se encuentra y con que capas colisiona. Para que se produzca una colisión,
    los cuerpos deben cumplir una condición, y es que, la capa del cuerpo A debe de estar marcada para que colisione con la del cuerpo B y viceversa.

    \medskip

    El manager guarda un mapa para las capas donde la clave es el nombre de la capa y el valor un indice que la representa. Cuando se crea un nuevo cuerpo físico, se calculan sus máscaras de bits a partir
    de ese índice.

    \item \textit{DebugDraw}: Clase que contiene la funcionalidad para dibujar los cuerpos físicos de Box2D. En concreto, puede dibujar polígonos, círculos, segmentos y puntos. El dibujado se realiza con SDL
    y antes de dibujar, se utiliza el \textit{screenToWorldFactor} para devolver la escala a los cuerpos, es decir, de unidades físicas a pixeles.
\end{itemize}


% ----------------------------------------------- RENDERER -------------------------------------------------

\subsection{Renderer}

Este proyecto hace uso de las librería de SDL, SDL\_Image y SDL\_TTF.

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}
    \item \textit{RendererManager}: Clase, \texttt{Singleton}, encargada de inicializar y cerrar la librería de SDL, SDLImage y SDLTTF. Contiene información y funcionalidad relacionada con la ventana como su
    tamaño, borde, icono, cursor, nombre y modo pantalla completa. Además, proporciona los métodos renderizar y para limpiar la pantalla.

    \item \textit{Font}: Representa una fuente de texto y tiene la funcionalidad de crear una a partir de una fichero con \textit{'.ttf'} como extensión. Tiene también la funcionalidad de crear un texto o un
    texto ajustado mediante la creación de una textura.

    \item \textit{Texture}: Representa una textura y tiene la funcionalidad de crear una a partir de un fichero con una extensión de imagen como \textit{'.png'} o \textit{'.jpg'}.
\end{itemize}

Al igual que \texttt{SoundEffect} y \texttt{MusicEffect}, \texttt{Font} y \texttt{Texture} representan los recursos utilizado en el manager de recursos
para almacenar fuentes de texto e imágenes.



% ----------------------------------------------- ENTITY COMPONENT ARQUITECTURE -------------------------------------------------

\subsection{Arquitectura de gameplay}

Como arquitectura de gameplay se ha implementado de tipo entidades y componentes.

Este es el proyecto más importante del motor. Implementa la arquitectura, componentes fundamentales para el usuario y una serie de managers como el de escenas, prefabs, referencias y overlay.

\medskip

Para llevar a cabo la implementación de la arquitectura es imprescindible el uso de programación orientada a objetos (POO) junto con herencia y polimorfismo. 

\medskip

La partes fundamentales de esta arquitectura son las siguientes: 

\begin{enumerate}
    \item \textit{Component}: Clase que representa a un componente. Contiene una referencia a la entidad a la que está asociado e información sobre si esta activo o eliminado. Desde un componente se puede 
    acceder a la entidad y escena que lo contiene y establecer su estado, es decir, activarlo o desactivarlo y eliminarlo. Además, contiene una serie de métodos virtuales preparados para ser implementados
    por los componentes que hereden de esta clase.

    \item \textit{Entity}: clase que representa una entidad. Contiene una referencia a la escena en la que se encuentra, una lista de componentes y otra de scripts asociados a esta entidad. Tiene información 
    sobre el nombre de la entidad, su estado, activa y eliminada, un identificador y su orden de renderizado.

    \item \textit{Scene}: La última pieza que compone esta arquitectura son las escenas. Una escena es un conjunto de entidades. Es un concepto importante en los videojuegos ya que normalmente se quiere dividir
    el juego en estados como menús, gameplay, inventario, pantallas de carga, mapa, etc. Contiene información sobre su nombre y bastantes métodos comunes a las entidades y componentes.
\end{enumerate}

Como hemos dicho anteriormente, las entidades funcionan como contenedores y los que realmente implementan la funcionalidad son los componentes. Por ello, las entidades únicamente se encarga de mantener 
actualizados a todos los componentes que tengan asociados. Además de los métodos para actualizar a los componentes, las entidades tiene métodos para añadir componentes, consultar si contienen un componente y 
eliminarlos.

\subsubsection{Managers y componentes}

Por otro lado, en este proyecto se implementan también los managers necesarios para el funcionamiento del motor y los componentes fundamentales que el motor va a proporcionar al usuario.

En cuanto a los componentes:

\begin{enumerate}

    \item \textit{Transform}: Contiene la información sobre la posición, rotación y escala de la entidad. Además implementa algunos métodos para rotar, escalar y mover la entidad.

    \item \textit{Overlay}: Componente encargado de representar los elementos de la interfaz de usuario como textos, imágenes y botones.

    \item \textit{Image}: Componente encargado de cargar una imagen y renderizarla en pantalla en la posición indicada por el transform de la entidad. Para cargar la imagen hace uso del manager de recursos para
    reutilizar la imagen en caso de estar ya creada por otra entidad. 

    \item \textit{PhysicBody}: Componente encargado de crear un cuerpo físico de Box2D. Implementa la funcinalidad de sincronizar posición, rotación y escala del \texttt{Transform} de la entidad al cuerpo físico.
    Contiene la información sobre bastante propiedades físicas como el tipo de cuerpo (estático, cinemático, dinámico), el rozamiento o la escala de la gravedad. De esta clase heredan \texttt{BoxBody}, 
    \texttt{CircleBody} y \texttt{EdgeBody}, que son cuerpos físicos cuyos colisionadores tienen formas especiales.

    \item \textit{SoundEmitter}: Componente encargado de cargar un sonido e implementar métodos para reproducirlo, detenerlo, pausarlo, etc. Como se comentó anteriomente, SDLMixer dispone de un conjunto de canales
    para reproducir sonidos pero este componente es abstrae la necesidad de canales desde la perspectiva del usuario. 

    \item \textit{MusicEmitter}: Componente encargado de cargar música e implementar métodos para reproducirla, detenerla, pausarla, rebobinarla, etc.

    \item \textit{ParticleSystem}: Componente encargado de implementar un sistema de partículas configurable. Tiene soporte para cargar texturas y mover las partículas con el motor de físicas Box2D.

    \item \textit{Animation}: Componente encargado de implementar la lógica de reproducción de animaciones.

    \item \textit{TopDownController}: Componente encargado de implementar un movimiento tipo Top-Down. 

    \item \textit{PlatformController}: Componente encargado de implmentar un movimiento de tipo plataformas.

    Estos dos útlimos componentes no son fundamentales pero aportan comodidad porque evitan al usuario tener que implementarlos usando el sistema de scripting, lo que puede ser algo avanzado.
    Mencionar también que es obligatorio que las entidades tengan al menos un componente, Transform u Overlay. Esto es así para poder distinguir entre entidades destinadas a la interfaz de usuario y el resto
    de entidades de la escena.

\end{enumerate}

En cuanto a los managers:

\begin{enumerate}
    \item \textit{SceneManager}: encargado de manejar las escenas. Para ello, cuenta con una pila en la que va almacenando las escenas que se crean.
    La escena que se va actualizar en el juego es la que se encuentra en el top de la pila. Hay 5 operaciones que se pueden realizar:

    \begin{itemize}
        \item \textit{Operación PUSH}: carga la escena y la añade al top de la pila.

        \item \textit{Operación POP}: elimina la escena en el top de la pila y avisa, a la escena por debajo del top, si la hay, que va a empezar
        a actualizarse.

        \item \textit{Operación POPANDPUSH}: realiza una operación \texttt{POP} y posteriormente una operación \texttt{PUSH}.

        \item \textit{Operación CLEARANDPUSH}: vacia la pila de escenas y añade una nueva al top de la pila que va a empezar a actualizarse.

        \item \textit{Operación CLEAR}: vacia la pila de escenas.
    \end{itemize}

    \item \textit{SceneLoader}: Clase encargado de leer la información de la escenas creadas en el editor. A la hora de construir la entidades diferencia entre entidades con \texttt{Transform} y entidades
    con \texttt{Overlay}.

    \item \textit{PrefabsManager}: Encargado de cargar la información de los prefabs creados en el editor e implementar métodos para instanciar entidades a partir de la información de esos prefabs. Se 
    diferencia entre prefabs con \texttt{Transform} y prefabs con \texttt{Overlay}. 

    \item \textit{RenderManager}: Encargado de renderizar por orden las entidades de la escena. A la hora de desarrollar en juego es deseable poder elegir elegir el orden en el que se renderizan las 
    entidades. Esto también se conoce como profundidad o z-order.

    \item \textit{ReferencesManager}: Encargado de manejar una relación entre las entidades y sus identificadores. Necesario para evitar problemas de referencias entre entidades.
\end{enumerate}


% ----------------------------------------------- PROYECTO PRINCIPAL -------------------------------------------------

\subsection{Bucle principal}

Este proyecto implementa la clase \texttt{Engine}, encargada de inicializar el motor, ejecutar su bucle principal y cerrarlo una vez terminado.

\medskip

En cuanto al bucle principal, tiene la siguiente estructura:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/EstructuraBuclePrincipal}
\end{center}

Además de esos métodos, se realizan cálculos de tiempo para proporcionar al usuario el \texttt{DeltaTime}, tiempo transcurrido desde el inicio de la ejecución del programa o el número de frames/actualizaciones
hasta el momento. El \texttt{DeltaTime} es una medida de tiempo, generalmente en milisegundos, que informa sobre el tiempo transcurrido entre la iteración anterior y la actual. 

\medskip

Algo a comentar es la diferencia entre el \texttt{Paso físico} y la \texttt{Actualización}. La lbrería de físicas Box2D, y todas en general, requieren que la actualización del mundo físico se realice en intervalos
de tiempo fijo, principalmente por motivos de estabilidad. Por ello, es necesario hacer cálculos adicionales para saber en que momentos se debe ejecutar el Paso Físico ya que no se puede llamar en cada frame, a 
diferencia de la \texttt{Actualización}.

\medskip

La potencia del hardware de la computadora y la carga de trabajo afectan directamente al número de actualizaciones por segundo que se producen en el bucle principal de un videojuego. Por lo tanto, la llamada al 
método \texttt{Actualización} se puede dar con mucha irregularidad. Sin embargo, el motor de física necesita intervalos de tiempo fijo.

\medskip

Esto se explica mejor con el siguiente diagrama:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/UpdateVsFixed}
\end{center}

Como se puede apreciar, el \texttt{Paso físico}, marcado en verde, siempre se ejecuta en el mismo intervalo de tiempo. Ese intervalo de tiempo fijo es un valor que se puede modificar en base a las necesidades
del videojuego.


\section{Cómo se genera la información necesaria para el editor}

% Reflexión

\section{Cómo funciona el scripting por nodos}



\section{Cómo se traduce un script a lógica en C++}
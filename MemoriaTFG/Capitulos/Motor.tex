%---------------------------------------------------------------------
%
%                          Motor
%
%---------------------------------------------------------------------

\chapter{Motor}

\section{Cómo funciona y cómo está dividio}

El motor esta dividio en diez proyectos de tecnología y cada uno cumple una función específica.

\medskip

A continuación se entrará en detalle sobre la función y detalles de implementación de cada proyecto y de las librerías asociadas al mismo, si las tiene.


% ----------------------------------------------- UTILIDADES -------------------------------------------------

\subsection{Utilidades}

El objetivo de este proyecto es implementar código común que pueden necesitar el resto  de proyectos evitando así la duplicación de código innecesaria.
Contiene clases tanto orientadas a guardar información como a implementar lógica y funcionalidad.

\medskip

Entre estas clases destacan las siguientes:

\begin{itemize}

    \item \texttt{Vector2D}: Representa un vector bidimensional, contiene información de dos componentes e implementa muchas de sus operaciones básicas. 
    
    \item \texttt{Random}: Contiene métodos estáticos útiles para calcular aleatoriedad entre números enteros, números reales, ángulos, y colores. 
    
    \item \texttt{Color}: Representa un color de tres canales (Red, Green, Blue) además de métodos con algo de funcionalidad como \texttt{Lerp}, que calcula
    un color intermedio entre otros dos dados y un porcentaje que representa la influencia que tendrá cada color en el color resultante. 
    
    \item \texttt{EngineTime}: Por un lado, contiene información sobre el tiempo entre fotogramas del motor, tiempo entre pasos físicos, tiempo transcurrido 
    desde el inicio del programa y número de fotogramas hasta el momento.
    
    \item \texttt{Singleton}: Una plantilla para crear instancias estáticas a través de herencia. Es decir, en caso de querer convertir una clases en un \texttt{Singleton}, muy útiles para managers, simplemente hay que heredar de esta clase  para conseguirlo. 
    
\end{itemize}




% ----------------------------------------------- RECURSOS -------------------------------------------------

\subsection{Recursos}

El objetivo de este proyecto es proporcionar un contenedor de recursos en el que se van a guardar todos los recursos del videojuego. En concreto, el tipo de
recursos que se pueden guardar son fuentes de texto, imágenes, efectos de sonido y música.

\medskip

El manager de recursos contiene un mapa por cada tipo de recurso donde la clave es la ruta del archivo y el valor un puntero a un objeto del tipo del recurso
(\texttt{Texture*}, \texttt{Font*}, \texttt{Sound*}, \texttt{Music*}). El hecho de utilizar un mapa se debe a la complejidad constante de acceder a los
recursos una vez creados.

\medskip

Esto es importante porque uno de los objetivos del manager de recursos es reutilizar los recursos creados para solo tener cargada una copia de cada recurso en
memoria. Por ello, a la hora de añadir un nuevo recurso al manager, primero comprueba si ya lo contiene y en ese caso, lo devuelve, en caso contrario, lo crea.

\medskip

Ya que la clave en los mapas es la ruta del archivo, los recursos pueden duplicarse en caso de tener el mismo archivo en diferentes directorios. El manager no
contempla ese escenario ya que realmente el archivo también esta duplicado y es responsabilidad del desarrollador ordenar sus archivos de assets.




% ----------------------------------------------- SONIDO -------------------------------------------------

\subsection{Sonido}

El objetivo de este proyecto es construir un envoltorio sobre la librería de audio \texttt{SDL\_Mixer} para poder implementar posteriormente los componentes
\texttt{MusicEmitter} y \texttt{SoundEmitter}.

\medskip

Para un mejor entendimiento de la implementación es necesario saber que \texttt{SDL\_Mixer} diferencia entre efectos de sonido o sonidos cortos en general (WAV, MP3)
y música de fondo (WAV, MP3, OGG).

\medskip

Para la música, la librería solo cuenta con un canal de reproducción por lo que es algo limitado pero simple a la vez ya que no hay que lidiar con número de canales, 
al contrario que con los efectos de sonido.

\medskip

Este proyecto cuenta con tres clases:

\begin{itemize}

\item \texttt{SoundEffect}: Representa un efecto de sonido. Contiene la información de un MixChunk de SDL\_Mixer y un identificador usado posteriormente por el componente
\texttt{SoundEmitter}.

\item \texttt{MusicEffect}: Representa un sonido de música de fondo. Contiene la información de un \texttt{MixMusic} de \texttt{SDL\_Mixer} y un identificador usado 
posteriormente por el componente \texttt{MusicEmitter}.

Estas dos clases representan también los recursos que se usan para música y sonidos en el 
manager de recursos.

\item \texttt{SoundManager}: Manager \texttt{Singleton} encargado de implementar el envoltorio de las funciones principales de \texttt{SDL\_Mixer} para reproducir, parar,
y detener sonidos, entre otros. Tiene dos métodos destinados al usuario para el modificar el volumen general y cambiar el número de canales disponibles para la reproducción
de efectos de sonidos.

\end{itemize}


% ----------------------------------------------- INPUT -------------------------------------------------

\subsection{Input}

Este proyecto tiene como objetivo implementar un manager, también \texttt{Singleton}, que contendrá la información del estado de las teclas/botones de los dispositivos de
entrada. En concreto, cuenta con soporte para teclado, ratón y mando.

\medskip

En el manager, las teclas/botones pueden pasar por diferentes estados los cuales se establecen al recibir determinados
eventos de SDL y se actualizan debidamente.

\medskip

Estos estados se dividen en:

\begin{enumerate} 
    \item \textit{Down}: Una tecla esta siendo pulsada. 
    \item \textit{Up}: Una tecla no esta siendo pulsada. 
    \item \textit{Pressed}: Una tecla acaba de ser pulsada. 
    \item \textit{Released}: Una tecla acaba de ser soltada. 
\end{enumerate} 

\begin{itemize} 

\item \textit{Teclado}: Guarda la información sobre la mayoría de teclas importantes de un teclado. Letras, números y teclas especiales. Para ello, el manager cuenta con tres
enumerados que contienen el nombre de cada una de las teclas para cada tipo.

\item \textit{Ratón}: Guarda la información de la posición del ratón, del estado del clic izquierdo, clic central (de la rueda), clic derecho y movimiento de la rueda.

\item \textit{Mando}: Cuenta con soporte para múltiples mandos y cada uno de ellos guarda la siguiente información:  

\begin{enumerate} 
    \item Nombre del mando.
    \item Estado de cada uno de los botones del mando.
    \item Información del movimiento de los triggers del mando.
    \item Información del movimiento de los joysticks del mando.
\end{enumerate}

El manager tiene sporte además para conexiones y desconexiones durante la ejecución. Debido a la posibilidad de tener varios mandos conectados el manager diferencia entre métodos
con identificador y métodos sin identificador. Los métodos con identificador reciben el identificador del mando del que se quiere consultar el estado y los métodos sin identificador
devuelven la información del estado del último mando que registró input. De esa manera, si se quiere desarrollar un singleplayer, el usuario no tendrá que preocuparse por la posibilidad
de múltiples mandos teniendo que indicar que identificador tiene su mando. 

\end{itemize}

Por último, el manager implementa métodos de lógica para el usuario como movimiento horizontal y vertical, salto o acción.



% ----------------------------------------------- CONSOLA -------------------------------------------------

\subsection{Consola}

Este proyecto contiene una sola clase Output con métodos estáticos que implementan funcionalidad relacionada con el mostrado de la salida estándar por la consola.

\medskip

Tiene métodos para imprimir por consola con los colores por defecto, imprimir una advertencia, con color amarillo e imprimir un error, con color rojo, entre otros.

\medskip

Además de ser útil para el desarrollo, sirve también para dar formato a los mensajes que aparecen por la consola del editor. Se utiliza una tubería o pipe para conectar la consola del motor
y la del editor. Esto se cuenta más en detalle en el apartado de editor.





% ----------------------------------------------- FISICAS -------------------------------------------------

\subsection{Físicas}

Este proyecto tiene como objetivo implementar un envoltorio sobre la librería de físicas Box2D para proporcionar una API sencilla para el usuario y para desarrollar los componentes de colisión
y movimiento físico necesarios.

\medskip

Antes de nada, al igual que con \texttt{SDL\_Mixer}, algunos conceptos sobre la librería: 

\begin{itemize}
    \item \textit{Mundo físico}: La librería tiene una clase b2World que representa un mundo físico donde se pueden crear cuerpos físicos. Esta clase tiene un método fundamental \texttt{Step()}, 
    al que se debe llamar para realizar un paso físico, lo que actualiza la simulación al avanzar el tiempo en un intervalo fijo, realiza cálculo de colisiones, resuelve restricciones y actualiza
    posiciones y velocidades. 

    \item \textit{Unidades}: Box2D trabaja con números de punto flotante y es necesario tener en cuenta alguna restricciones para que Box2D funcione correctamente. Estas restricciones han sido 
    ajustadas para funcionar bien con unidades de metros-kilogramos-segundos (MKS). En particular, Box2D ha sido ajustado para funcionar adecuadamente con formas en movimiento que tienen dimensiones
    entre 0.1 y 10 metros.

    \item \textit{Pixeles}: Es tentador usar pixeles como unidades para los tamaños, posiciones, fuerzas o velocidades pero desafortunadamente, esto llevaría a una simulación ineficiente y posiblemente
    a un comportamiento extraño. En la propia documentación de Box2D comentan que un objeto de 200 píxeles de longitud sería visto por Box2D como el tamaño de un edificio de 45 pisos.
\end{itemize}

Para resolver el problema de los pixeles, se usa un valor \textit{screenToWorldFactor} usado para convertir de pixeles a unidades físicas y viceversa. Por lo tanto, a la hora de crear cuerpos
físicos se convierte el tamaño en pixeles deseado por el usuario a unidades físicas utilizando ese factor de escala.

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}
    \item \textit{PhysicsManager}: Clase, \texttt{Singleton}, que contiene la funcionalidad necesariara para manejar el filtrado de colisiones e información sobre gravedad del mundo físico así como la
    matriz de colisiones y capas existentes.

    \medskip

    En cuanto al filtrado de colisiones, cada objeto físico tiene máscaras de bits donde guarda la información sobre en que capa se encuentra y con que capas colisiona. Para que se produzca una colisión,
    los cuerpos deben cumplir una condición, y es que, la capa del cuerpo A debe de estar marcada para que colisione con la del cuerpo B y viceversa.

    \medskip

    El manager guarda un mapa para las capas donde la clave es el nombre de la capa y el valor un indice que la representa. Cuando se crea un nuevo cuerpo físico, se calculan sus máscaras de bits a partir
    de ese índice.

    \item \textit{DebugDraw}: Clase que contiene la funcionalidad para dibujar los cuerpos físicos de Box2D. En concreto, puede dibujar polígonos, círculos, segmentos y puntos. El dibujado se realiza con SDL
    y antes de dibujar, se utiliza el \textit{screenToWorldFactor} para devolver la escala a los cuerpos, es decir, de unidades físicas a pixeles.
\end{itemize}


% ----------------------------------------------- RENDERER -------------------------------------------------

\subsection{Renderer}

Este proyecto hace uso de las librería de SDL, SDL\_Image y SDL\_TTF.

Las clases que tiene este proyecto son las siguientes:

\begin{itemize}
    \item \textit{RendererManager}: Clase, \texttt{Singleton}, encargada de inicializar y cerrar la librería de SDL, SDLImage y SDLTTF. Contiene información y funcionalidad relacionada con la ventana como su
    tamaño, borde, icono, cursor, nombre y modo pantalla completa. Además, proporciona los métodos renderizar y para limpiar la pantalla.

    \item \textit{Font}: Representa una fuente de texto y tiene la funcionalidad de crear una a partir de una fichero con \textit{'.ttf'} como extensión. Tiene también la funcionalidad de crear un texto o un
    texto ajustado mediante la creación de una textura.

    \item \textit{Texture}: Representa una textura y tiene la funcionalidad de crear una a partir de un fichero con una extensión de imagen como \textit{'.png'} o \textit{'.jpg'}.
\end{itemize}

Al igual que \texttt{SoundEffect} y \texttt{MusicEffect}, \texttt{Font} y \texttt{Texture} representan los recursos utilizado en el manager de recursos
para almacenar fuentes de texto e imágenes.



% ----------------------------------------------- ENTITY COMPONENT ARQUITECTURE -------------------------------------------------

\subsection{Arquitectura de gameplay}

Como arquitectura de gameplay se ha implementado de tipo entidades y componentes.

Este es el proyecto más importante del motor. Implementa la arquitectura, componentes fundamentales para el usuario y una serie de managers como el de escenas, prefabs, referencias y overlay.

\medskip

Para llevar a cabo la implementación de la arquitectura es imprescindible el uso de programación orientada a objetos (POO) junto con herencia y polimorfismo. 

\medskip

La partes fundamentales de esta arquitectura son las siguientes: 

\begin{enumerate}
    \item \textit{Component}: Clase que representa a un componente. Contiene una referencia a la entidad a la que está asociado e información sobre si esta activo o eliminado. Desde un componente se puede 
    acceder a la entidad y escena que lo contiene y establecer su estado, es decir, activarlo o desactivarlo y eliminarlo. Además, contiene una serie de métodos virtuales preparados para ser implementados
    por los componentes que hereden de esta clase.

    \item \textit{Entity}: clase que representa una entidad. Contiene una referencia a la escena en la que se encuentra, una lista de componentes y otra de scripts asociados a esta entidad. Tiene información 
    sobre el nombre de la entidad, su estado, activa y eliminada, un identificador y su orden de renderizado.

    \item \textit{Scene}: La última pieza que compone esta arquitectura son las escenas. Una escena es un conjunto de entidades. Es un concepto importante en los videojuegos ya que normalmente se quiere dividir
    el juego en estados como menús, gameplay, inventario, pantallas de carga, mapa, etc. Contiene información sobre su nombre y bastantes métodos comunes a las entidades y componentes.
\end{enumerate}

Como hemos dicho anteriormente, las entidades funcionan como contenedores y los que realmente implementan la funcionalidad son los componentes. Por ello, las entidades únicamente se encarga de mantener 
actualizados a todos los componentes que tengan asociados. Además de los métodos para actualizar a los componentes, las entidades tiene métodos para añadir componentes, consultar si contienen un componente y 
eliminarlos.

\subsubsection{Managers y componentes}

Por otro lado, en este proyecto se implementan también los managers necesarios para el funcionamiento del motor y los componentes fundamentales que el motor va a proporcionar al usuario.

En cuanto a los componentes:

\begin{enumerate}

    \item \textit{Transform}: Contiene la información sobre la posición, rotación y escala de la entidad. Además implementa algunos métodos para rotar, escalar y mover la entidad.

    \item \textit{Overlay}: Componente encargado de representar los elementos de la interfaz de usuario como textos, imágenes y botones.

    \item \textit{Image}: Componente encargado de cargar una imagen y renderizarla en pantalla en la posición indicada por el transform de la entidad. Para cargar la imagen hace uso del manager de recursos para
    reutilizar la imagen en caso de estar ya creada por otra entidad. 

    \item \textit{PhysicBody}: Componente encargado de crear un cuerpo físico de Box2D. Implementa la funcinalidad de sincronizar posición, rotación y escala del \texttt{Transform} de la entidad al cuerpo físico.
    Contiene la información sobre bastante propiedades físicas como el tipo de cuerpo (estático, cinemático, dinámico), el rozamiento o la escala de la gravedad. De esta clase heredan \texttt{BoxBody}, 
    \texttt{CircleBody} y \texttt{EdgeBody}, que son cuerpos físicos cuyos colisionadores tienen formas especiales.

    \item \textit{SoundEmitter}: Componente encargado de cargar un sonido e implementar métodos para reproducirlo, detenerlo, pausarlo, etc. Como se comentó anteriomente, SDLMixer dispone de un conjunto de canales
    para reproducir sonidos pero este componente es abstrae la necesidad de canales desde la perspectiva del usuario. 

    \item \textit{MusicEmitter}: Componente encargado de cargar música e implementar métodos para reproducirla, detenerla, pausarla, rebobinarla, etc.

    \item \textit{ParticleSystem}: Componente encargado de implementar un sistema de partículas configurable. Tiene soporte para cargar texturas y mover las partículas con el motor de físicas Box2D.

    \item \textit{Animation}: Componente encargado de implementar la lógica de reproducción de animaciones.

    \item \textit{TopDownController}: Componente encargado de implementar un movimiento tipo Top-Down. 

    \item \textit{PlatformController}: Componente encargado de implmentar un movimiento de tipo plataformas.

    Estos dos útlimos componentes no son fundamentales pero aportan comodidad porque evitan al usuario tener que implementarlos usando el sistema de scripting, lo que puede ser algo avanzado.
    Mencionar también que es obligatorio que las entidades tengan al menos un componente, Transform u Overlay. Esto es así para poder distinguir entre entidades destinadas a la interfaz de usuario y el resto
    de entidades de la escena.

\end{enumerate}

En cuanto a los managers:

\begin{enumerate}
    \item \textit{SceneManager}: encargado de manejar las escenas. Para ello, cuenta con una pila en la que va almacenando las escenas que se crean.
    La escena que se va actualizar en el juego es la que se encuentra en el top de la pila. Hay 5 operaciones que se pueden realizar:

    \begin{itemize}
        \item \textit{Operación PUSH}: carga la escena y la añade al top de la pila.

        \item \textit{Operación POP}: elimina la escena en el top de la pila y avisa, a la escena por debajo del top, si la hay, que va a empezar
        a actualizarse.

        \item \textit{Operación POPANDPUSH}: realiza una operación \texttt{POP} y posteriormente una operación \texttt{PUSH}.

        \item \textit{Operación CLEARANDPUSH}: vacia la pila de escenas y añade una nueva al top de la pila que va a empezar a actualizarse.

        \item \textit{Operación CLEAR}: vacia la pila de escenas.
    \end{itemize}

    \item \textit{SceneLoader}: Clase encargado de leer la información de la escenas creadas en el editor. A la hora de construir la entidades diferencia entre entidades con \texttt{Transform} y entidades
    con \texttt{Overlay}.

    \item \textit{PrefabsManager}: Encargado de cargar la información de los prefabs creados en el editor e implementar métodos para instanciar entidades a partir de la información de esos prefabs. Se 
    diferencia entre prefabs con \texttt{Transform} y prefabs con \texttt{Overlay}. 

    \item \textit{RenderManager}: Encargado de renderizar por orden las entidades de la escena. A la hora de desarrollar en juego es deseable poder elegir elegir el orden en el que se renderizan las 
    entidades. Esto también se conoce como profundidad o z-order.

    \item \textit{ReferencesManager}: Encargado de manejar una relación entre las entidades y sus identificadores. Necesario para evitar problemas al acceder a la referencia de una entidades.
\end{enumerate}


% ----------------------------------------------- PROYECTO PRINCIPAL -------------------------------------------------

\subsection{Bucle principal}

Este proyecto implementa la clase \texttt{Engine}, encargada de inicializar el motor, ejecutar su bucle principal y cerrarlo una vez terminado.

\medskip

En cuanto al bucle principal, tiene la siguiente estructura:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/EstructuraBuclePrincipal}
\end{center}

Además de esos métodos, se realizan cálculos de tiempo para proporcionar al usuario el \texttt{DeltaTime}, tiempo transcurrido desde el inicio de la ejecución del programa o el número de frames/actualizaciones
hasta el momento. El \texttt{DeltaTime} es una medida de tiempo, generalmente en milisegundos, que informa sobre el tiempo transcurrido entre la iteración anterior y la actual. 

\medskip

Algo a comentar es la diferencia entre el \texttt{Paso físico} y la \texttt{Actualización}. La lbrería de físicas Box2D, y todas en general, requieren que la actualización del mundo físico se realice en intervalos
de tiempo fijo, principalmente por motivos de estabilidad. Por ello, es necesario hacer cálculos adicionales para saber en que momentos se debe ejecutar el Paso Físico ya que no se puede llamar en cada frame, a 
diferencia de la \texttt{Actualización}.

\medskip

La potencia del hardware de la computadora y la carga de trabajo afectan directamente al número de actualizaciones por segundo que se producen en el bucle principal de un videojuego. Por lo tanto, la llamada al 
método \texttt{Actualización} se puede dar con mucha irregularidad. Sin embargo, el motor de física necesita intervalos de tiempo fijo.

\medskip

Esto se explica mejor con el siguiente diagrama:

\begin{center}
    \includegraphics[scale=0.3]{Imagenes/Vectorial/UpdateVsFixed}
\end{center}

Como se puede apreciar, el \texttt{Paso físico}, marcado en verde, siempre se ejecuta en el mismo intervalo de tiempo. Ese intervalo de tiempo fijo es un valor que se puede modificar en base a las necesidades
del videojuego.


\section{Cómo se serializa la información del motor}


El motor está hecho en c++, lo cual supone una limitación a la hora del paso información debibo a la carencia de reflexión. La reflexión es la capacidad de dotar a un lenguaje con introspección, pudiendo conocer su propia estructura o incluso modificarla en tiempo de ejecución. 
Esta cualidad es especialmente útil pues permitiría la capacidad de conocer las distintas clases y métodos de los que dispone el motor, así como poder consultar y modificar los atributos de clases. \\
Para solvertar esta carencia el motor cuenta con un proyecto adicional llamado \textit{ECSReader}. 
Este proyecto tiene la función de entender la estructura de componentes para más adelante poder serializar esta información. Este proyecto no tiene utilidad durante la ejecución del motor, y se trata de una herramienta que puede ejecutar el desarrollador en cualquier momento que considere oportuno.

Podemos dividir el ciclo de vida de la ejecución de este programa en dos fases: la lectura de los datos del motor y en la generación de nuevos recursos.

\subsection{Lectura del motor}

Dadas una rutas importantes con las ubicaciones del código fuente del motor, el programa se encarga de leer cada uno de los ficheros que se encuentren en las rutas dadas. A medida que va leyendo cada fichero, su información se va filtrando y procesando. La información que se guarda 
pertenece a los métodos y atributos de componentes y managers. No es necesario guardar cada método y atributo de cada componente, sólo los que sean de interés, por lo que para poder hacer este filtrado el motor cuenta con dos etiquetas principales: la etiqueta \textit{publish} y la etiqueta \textit{reflect}.
La primera se utiliza como un modificador de acceso en c++, y cada uno de los métodos que procedan a la etiqueta serán los que sean serializados hasta encontrar el siguiente modificador de acceso. La segunda etiqueta etiqueta está pensada para los atributos, y cada atributo que sea precedido por esa etiqueta son los que serán almacenados.
Este uso de las etiquetas proporciona una gran comodidad y control al desarrollador, permitiéndole controlar qué partes del motor permanecerán expuestas.
Durante la ejecición del \textit{ECSReader}, se almacena información sobre cada componente, al igual que también se almacena los métodos y atributos requeridos, guardando información como el nombre dado o su tipo. El programa además también tiene en cuenta la herencia de componentes, proporcionando a un componente la funcionalidad de su padre.

\subsection{Recursos generados}

Una vez todos los ficheros dados son leídos, comienza el proceso de generación de recursos. La función de estos recursos es de vital importancia, tanto para la comunicación del motor con el editor, como para el propio funcionamiento del editor. A continuación se menciona cada fichero generado junto con su utilidad.

\begin{enumerate}
    \item \textit{FunctionManager}: Se trata de un par de ficheros en c++, uno siendo el fichero de cabecera y otro de fuente. Entre estos dos ficheros se genera una función para cada método que se haya leído. Además, este fichero cuenta con funcionalidad para agrupar cada una de las funciones en una única estructura, de tal forma que se pueda acceder a cada
    una de las funciones conociéndo únicamente su nombre. Se genera una función para método para de esta forma todas las funciones tengan la misma estructura y además poder hacer manejo de errores antes de redirigir la llamada al método original.

    \item  \textit{ClassReflection}: Se trata de una clase en c++ compuesta por dos ficheros, uno siendo el fichero de cabecera y otro de fuente. Esta clase de manipular los atributos de cada componente, simulando la reflexión. Con esta clase se puede modificar cada atributo conociendo únicamente su nombre, lo cual es importante durante el proceso de deserialización
    de una escena.
    
    \item  \textit{ComponentFactory}: Se trata de una clase en c++ compuesta por dos ficheros, uno siendo el fichero de cabecera y otro de fuente. Esta clase tiene la función de generar un componente de un tipo determinado dado el nombre del tipo, siendo de vital importancia para el proceso de deserialización de una escena.

    \item  \textit{Ficheros para el editor}: Se generan dos ficheros, uno para componentes y otro para managers, ambos en formato JSON.\@ Estos contienen toda la información relacionada con cada componente y manager, y se trata de los ficheros utilizados para la lectura de los datos del motor en el editor.

\end{enumerate}

Si bien estos ficheros podrían ser generados a mano, esta automatización supone un enorme ahorro de tiempo para el desarrollador. 


\section{Funcionamiento del lenguaje de scripting}

Este lenguaje está pensado para ser utilizado por un editor de programación visual, utilizando flechas y nodos. Las flechas tienen la función de transmitir valores entre nodos, para poder enlazarlos entre ellos y poder generar comportamientos más complejos. 
Este lenguaje está pensado para funcionar mendiante eventos, de forma que se pueda seleccionar qué partes del script queremos ejecutar en respuesta al evento recibido. Estos eventos funcionan como punto de partida inicial para la ejecución del script.
Esta ejecución funciona siguiendo un flujo. Por flujo nos referimos a la posibilidad de establecer el orden en el que se ejecutan los nodos, garantizando que el script se comporte siempre de la misma forma. Al igual que las flechas representando las conexiones de nodos entre valores,
las conexiones de flujo también estarán representadas de forma visual, aunque esto se explicará más en detalle en el apartado del editor. TODO: referencia a la parte del editor. 


TODO: diagrama con el orden de ejecución de nodos

La ejecución de un script sigue la siguiente estructura. Primero se ejecuta el nodo inicial marcado por el evento, y antes de procesar dicho nodo se ejecutan cada una de sus entradas. A su vez, estas entradas siguen el mismo proceso ejecutando primero sus nodos de entrada correspondientes hasta dar 
con un nodo que no tenga entrada. Cuando todas las entradas y sub-entradas han sido procesadas es entonces cuando se ejecuta el propio, el cual pasará el flujo al siguiente. Este proceso se repite hasta dar con un nodo que no tenga ningún nodo siguiente. Durante este proceso un mismo nodo no puede
ser ejecutado dos veces, y el valor de salida de cada nodo debe ser guardado hasta que termine todo el proceso de ejecución. De esta forma se consigue optimizar la velocidad del lenguaje, reduciendo el número de procesado de nodos, además de mejorar su legibilidad y previsibilidad (por ejemeplo en un caso
donde un nodo genere un número aleatorio, poder usar el mismo número con cada acceso al nodo), al precio de no permitir hacer programas que funcionen de forma recursiva.


\medskip

Dependiendo de su funcionamiento existen varios tipos de nodos: 

\begin{enumerate}


    \item  \textit{Nodo de función}: Este nodo representa una función en el lenguaje, y puede tener entrada y un valor de salida, al igual que puede recibir y pasar el flujo del script. Este nodo puede ser serializado para ser llamado desde otro script, creando así algo semejante a un método en un lenguaje convencional.
    \item  \textit{Nodo de entrada}: Proporciona un valor constante que puede ser usado como entrada para una función. Este valor puede ser serializado para modificarse desde fuera permitiendo reutilizar scripts con datos diferentes. Este tipo de nodo no puede recibir el flujo.
    \item  \textit{Nodo de bifurcación}: Permite la implementación de lógica condicional y dos tipos de bucles, dependiendo del tipo interno asociado, haciendo posible modificar el flujo del script durante su ejecución. Recibe además un valor de entrada a modo de condición y no tiene un valor de salida.

\end{enumerate}

Todo esto permite al usuario crear comportamientos complejos de una manera visual sin tener que escribir ninguna línea de código.


\section{Integración scripting en el motor}

Una vez conociendo el lenguaje que ha sido diseñado para el motor, el siguiente punto interesante a tratar es cómo ha sido implementado en el motor.
Para su integración en el motor aparece un componente nuevo, llamado \textit{Script}, junto con un nuevo manager, \textit{ScriptManager}. Entre estas dos clases se establece el puente entre el motor y el funcionamiento del scripting. \textit{ScriptManager} funciona como un manejador de recursos de tipo script de forma
que no se generen copias innecesarias del recuros cuando el script sea reutilizado por otra entidad, al igual que se encarga de su correcta deserialización del formato JSON. Por otro lado, la clase \textit{Script} proporciona los eventos necesarios al lenguaje de scripting, redirigiendo los eventos recibidos de la clase componente, además de guardar información adicional 
para almacenar los distintos valores serializados. La clase \textit{Script} no maneja los nodos, sino que almacena punteros al nodo inicial de cada evento, en caso de que exista.


\medskip

TODO: diagrama con el esquema de las clases

Para la implementación de la lógica del scripting, se ha creado una clase por cada tipo de nodo, siendo responsable cada uno de manejar su propia información, y entre todos creando una jerarquía de clases para poder manejar el script mediante herencia y polimorfismo.
Para representar los valores dentro del editor, manejamos la abstracicción de una variable la cual puede tomar cualquier valor, y todo se procesa dentro de una unión (siendo una unión un tipo especial de clase en c++ que solo puede almacenar el valor de uno de sus miembros). 
El lenguaje está preparado para soportar los tipos: float, char, string, bool, un vector bidimensional de float, una estructura para representar un color y un puntero a una entidad.
Con el fin de simplificar el uso, hemos decidido no distinguir entre tipos númericos (como pueden ser el int o el float) sino manejar una agrupación de ellos, algo parecido al funcionamiento de Javascript. 
% TODO: meter una cita (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number) 

Con el mismo fin de simplificar las cosas, también hemos decidido descartar el uso del tipo componente. Por ello, en las llamadas a funciones donde hiciera falta el parámetro que se pasará será de tipo entidad, desde la cual se accederá al componente necesario. 

Para el tipo entidad hay dos casos de uso, dependiendo del origen del nodo que haya producido el valor. Si procede de una función, la variable se usa como puntero a la entidad dada, sin complicaciones, pero si el valor procede de un nodo de entrada, 
 su valor deserializado tiene el valor de su identificador como número entero, por lo cual antes de poder acceder al puntero tenemos que acceder al puntero haciendo uso del \textit{ReferencesManager}.


Para la ejecución de un nodo funcion, éste almacena el nombre de la función a ejecutar, con lo que se puede ejecutar la función asociada haciendo uso del \textit{FunctionManager}. Cabe mencionar, que en caso de que la función esté asociada a un componente en lugar de un manager, el primero parámetro será siempre un puntero a la entidad.


 Por último, para completar el lenguaje se ha creado la clase \textit{ScriptFunctionality} con funcionalidad básica para poder usar desde el script, como puede ser escribir por consola o realizar operaciones aritméticas.
%---------------------------------------------------------------------
%
%                          Contribuciones
%
%---------------------------------------------------------------------

\chapter{Contribuciones}

Como se comentó en el plan de trabajo, este TFG esta divido en tres partes fundamentales. Debido a que la carga
de trabajo de cada parte es similar, hemos asignado una parte a cada integrante del grupo. A pesar de esta división,
sobretodo durante la recta final del trabajo, se han dado contribuciones de todos los integrantes en cada una de las
tres partes, aunque eso sí, en menor medida.

%-------------------------------------------------------------------
\section{Pablo Fernández Álvarez}
%-------------------------------------------------------------------

Yo me he encargado de la parte del motor. Al principio me dediqué a investigar posibles librerías tanto de físicas
como de audio, para integrar al motor. En cuanto a librería de gráficos tuvimos claro desde el principio que íbamos
a usar SDL, debido a que la hemos usado bastante durante el grado y estamos acostumbrados, además de que no tiene
ninguna limitación para el desarrollo de videojuegos 2D. 

Una vez escogidas la librerías, Box2D como motor de física y SDLMixer como motor de audio, comencé a montar el proyecto
usando Visual Studio 2022. Organicé la solución en varios proyectos, física, audio, input, render, y fui implementando
cada uno de ellos. Empecé con el proyecto de Input, el cuál me llevó algo de tiempo ya que implementé soporte para teclado,
mando y múltiples mandos. Una vez terminado, fue el turno del proyecto de sonido/audio. Con la ayuda de la documentación
de SDLMixer, implementé soporte para la reproducción de efectos de sonido/sonidos cortos y música. Posteriormente comencé
con el proyecto de físicas. En este caso tuve que dedicar bastante más tiempo a aprender sobre la librería, leer artículos
y documentación, ya que es más compleja. Investigué también la opción de poder visualizar los colisionadores de los cuerpos
físicos ya que supondría una gran ayuda tanto para el desarrollo del motor como para el usuario. En la documentación de Box2D
encontré algunos ejemplos pero usaban el OpenGL para el dibujado y el motor usa SDL por lo que tuve que implementar esas
funciones de dibujado con SDL.

Luego llegó el momento de implementar el proyecto del ECS (Entity-Component-System), fundamental para realizar pruebas y 
visualizar las primeras escenas. Para ello además, implementé el bucle principal del motor con un intervalo de tiempo
fijo para el mundo físico. En este momento, con los proyectos principales implmentados, comencé a implementar los primeros
componentes básicos, como son el Transform, Image, PhyiscBody y SoundEmitter.

Durante un tiempo simplemente me dediqué a ampliar y probar los componentes y la funcionalidad implementada en los proyectos.
Por ejemplo, añadí una matriz de colisiones al proyecto de físicas para manejar el filtrado de colisiones, implementé distintos
tipos de PhyiscBody (colisionadores con formas especiales), sincronicé los cuerpos físicos con las transformaciones de la entidad,
detección de colisiones, conversión de píxeles a unidades físicas, nuevo componente ParticleSystem para sistemas de partículas, 
implementé un gestor de recursos para evitar cargar recursos duplicados, mejoré los componentes de sonido para añadir paneo 
horizontal y sonido 2D, entre otros. 

Con la parte del editor más avanzada, implementé la lógica necesaria para leer los datos que genera el editor, como
escenas o prefabs. Además, implementé la ventana de gestión de proyectos del editor, añadí control de errores en todo el motor, 
para conseguir una ejecución continua y esperable, imprimiendo los errores por la salida estándar. Añadí también control de 
errores en el editor, a través de un fichero de log, con la información de los errores durante la ejecución. Creé una estructura
de directorios para el editor y motor haciendo más cómodo el ciclo de desarrollo. Implementé una ventana de preferencias donde
ajustar parámetros del motor, como gravedad del mundo físico, frecuencia del motor de audio, tamaño de la ventana de juego, entre
muchos otros. Implementé el flujo de escenas, es decir, guardar la última escena abierta, mostrar el viewport de una forma especial
en caso de que no haya ninguna escena abierta y mostrar en el viewport el nombre de la escena actual junto con su contenido
correspondiente. 

Por último, cambié el uso que se hacía de SDL para la implementación de mando en el Input, de SDLJoystick a SDLGameController ya
que está más preparada para mando y SDLJoystick es una interfaz de más bajo nivel preparada para cualquier tipo de dispositivo.
Añadí más parámetros a la ventana de preferencias, sobretodo para Input, bindeo de teclas rápidas. He mejorado también la ventana
de gestión de proyectos para poder eliminar proyectos y ordenar los proyectos por orden de última apertura.



%-------------------------------------------------------------------
\section{Yojhan García Peña}
%-------------------------------------------------------------------

Mi principales tareas fueron el desarrollo del lenguaje de scripting, incluyendo su implementación tanto en el editor y en el motor, y también
la unión entre el editor y el motor.

\medskip

Inicialmente tuve que crear un proyecto vacío de Visual Studio para empezar a prototipar el lenguaje. No quería utilizar ninguna biblioteca externa
que implementase la lógica para un editor de nodos, pues prefería poder desarrollarlo desde cero. Tampoco he querido mirar en profundidad el  funcionamiento del lenguaje de scripting de otros motores como Unity o Unreal porque no queríamos copiar descaradamente su forma de uso y queríamos desarrollar un lenguaje propio
que se adaptase a las necesidades concretas de nuestro motor. \\

Fue un proceso iterativo donde poco a poco se iba añadiendo funcionalidad, y cuando finalmente conseguí una implementación que me parecía robusta fue
cuando decidímos juntar los dos primeros proyectos del TFG, siendo el motor y el scripting. Para poder llevar a cabo la integración tuve que hacer
la clase Script, que junto con las clases relacionadas con los nodos ya permitían enlazar los nodos con el bucle de juego principal del motor. También fue necesaria la creación de la clase ScriptFunctionality para poder dotar al lenguaje de funcionalidad básica como sumas, restas y operaciones genéricas
para la entrada. \\

Llegados a este punto pospuse un poco el desarrollo del scripting y empezé a centrarme en cómo sería la unión entre el editor y el motor. Tras varios
intentos fallidos finalmente terminé de desarrollar la clase ECSReader, con la cual se puede leer el contenido del motor gracias a unas marcas que
se pueden ir añadiéndo en el código. Y tras añadir al proyecto la biblioteca de lectura de JSON de nlohmann, toda la información relevantes del motor
pasaba a estar serializada en fichero en disco, siendo la idea que el motor pueda leer los valores desde ese fichero. \\
Aprovechando que el ECSReader ya estaba creado, fue usado para muchos más usos además de generar ficheros JSON. Finalmente terminamos utilizando el
ECSReader para generar código en c++ que pueda leer el motor, de esta forma, automatizando bastante muchos aspectos tediosos. El ECSReader genera tres
ficheros diferentes: ClassReflection, que permite serializar los atributos de una clase y poder dotarles de valor desde fuera conociendo el nombre de la
variable; ComponentFactory, que con el nombre de un componente en formato string crea un componente de ese tipo, siendo una especie de factoría; y FunctionManager, el cual genera una función para cada método de los componentes y luego los agrupa en un mapa.\\


\medskip
Con esto, ya estaba hecha la reflexión con la que queríamos dotar al motor, y siendo la persona que más avanzada iba con su parte decidí ayudar a mis compañeros con algunas tareas. Empezando por el motor y gracias a mi experiencia con serialización de JSON, hice serialización de escenas y entidades, seguido de la implementación del sistema de Overlays y sus componenetes asociados (Image, Button y Text), la Splash Screen y la serialización de información del proyecto, como tamaño de la ventana o el icono usado.


\medskip

Cuando el editor iba más avanzado me puse a implementar el editor visual de nodos en el editor. Terminando todo lo relacionado con el editor, y la 
serialización. Con mi parte terminada en gran medida, fue cuando me puse a hacer la lectura de los ficheros generados por el ECSReader en el Editor, por lo que tuve hacer la clase ComponentReader y ComponentManager. Con todo casi terminado, me puse a hacer cambios en el editor, haciendo una refactorización de cómo se dibujan las ventanas para incluir la rama de Docking de ImGUI en el editor, \
Para terminar, me puse a crear distintas ventanas de utilidades del editor, como el editor de la paleta de colores, la consola creando un PIPE que lee la salida del programa; la clase Game, que permite ejecutar el exe del motor y controlar el proceso pudiendo detenerlo en cualquier momento haciendo uso 
de la api de windows; el esqueleto de la clase de preferencias, el manejador del docking para poder cambiar la disposición de las ventanas y el renderizado de la ventana tanto para las entidades físicas como para la interfaz

\medskip

Por último, estuve implementando funcionalidad que se haya quedado sin implementar y corrigiendo errores.




%-------------------------------------------------------------------
\section{Iván Sánchez Míguez}
%-------------------------------------------------------------------

Mi principal responsabilidad en el proyecto se enfocó en el desarrollo del editor. En una fase inicial, mi tarea consistió en llevar a cabo una investigación exhaustiva de proyectos similares para comprender 
las bibliotecas gráficas utilizadas y evaluar si alguna de ellas podría simplificar nuestro trabajo. Después de un análisis minucioso, llegué a la conclusión de que IMGUI era la elección ideal debido a su 
amplio conjunto de funcionalidades para la interfaz de usuario (UI).

\medskip

Una vez seleccionada esta biblioteca, procedí a crear el proyecto en Visual Studio 2022. Inicié con la creación de un programa simple inicial para comprender cómo se inicializa y funciona IMGUI, el cual incluía 
un proyecto con numerosos ejemplos. Mi enfoque inicial se centró en el diseño de las ventanas principales, como la barra de menú, la jerarquía, la escena, los componentes y el explorador de archivos.
Esto se hizo de manera rápida y provisional con el único propósito de familiarizarme rápidamente con IMGUI. Durante este proceso, descubrí la rama 'imgui dock' de IMGUI, que permitía el anclaje de ventanas entre 
sí, lo que resultó ser una característica valiosa para el proyecto.

\medskip

Posteriormente, reestructuré dicho código para lograr una organización más intuitiva de las ventanas y facilitar la adición de nuevas ventanas. Para ello, cree la clase Window, que es la clase padre de cada 
ventana y se encarga de incluir la funcionalidad básica de una ventana de IMGUI. Avanzando en el proyecto, me concentré en la creación de la escena, un proceso que inicialmente resultó un tanto complicado 
debido a la complejidad en la programación, especialmente en lo que respecta al manejo de texturas y su renderización con IMGUI. Sin embargo, con el tiempo, logré comprender estos aspectos y refactorizar 
el código para obtener una forma más sencilla de renderizar la escena y sus entidades.

\medskip

Con la escena en funcionamiento, me dediqué a trabajar en la creación de entidades y su representación en la textura. Para ello, creé la clase Entidad, encargada de gestionar su textura y almacenar información 
sobre su Transform, además de asignar un ID único a cada entidad para diferenciarlas entre sí. Luego, me enfoqué en la gestión de estas entidades a través de la ventana de jerarquía, incorporando un listado 
con textos seleccionables mediante IMGUI, lo que permitió la selección de entidades. Esto también tuvo un impacto en otras ventanas, como la de componentes, que mostraba información sobre la entidad seleccionada. 
Inicialmente, la ventana de componentes mostraba solo la información del transform con entradas de IMGUI para modificar sus valores. Finalmente, desarrollé la ventana del explorador de archivos, que aunque 
al principio no la consideré esencial, resultó importante para la visualización de los activos del proyecto y la navegación entre directorios.

\medskip

Una vez que logramos tener una versión básica del editor, trabajé en su integración con el motor del proyecto. Esto implicó la serialización de escenas, entidades y sus transformaciones en formato JSON.
Posteriormente, tuve que adaptar el proceso de serialización para que fuera compatible con el motor, ya que este tenía formas distintas de leer los componentes disponibles, sus atributos y el tipo de sus atributos. 
Una vez incorporados los componentes del motor en el editor, me centré en el renderizado y la edición de estos, de modo que cada tipo de atributo tuviera su propia representación en la ventana de componentes, 
lo que se logró de manera eficiente gracias a IMGUI. También permití la adición de dichos componentes a las entidades.

\medskip

Posteriormente, me dediqué a la implementación de funciones más avanzadas, como el uso de prefabs y la gestión de la jerarquía entre entidades. Esto fue un desafío significativo, ya que implicaba rehacer el 
sistema de asignación de IDs para que los prefabs tuvieran IDs negativos y estuvieran referenciados en todas sus instancias. Además, fue necesario tener en cuenta este sistema de IDs en múltiples partes del 
código para evitar conflictos con el uso normal de las entidades. La gestión de la jerarquía también presentó complejidades, ya que cada entidad contenía referencias a su padre y sus hijos, lo que debía 
considerarse en numerosas partes del código. La interacción entre prefabs y la jerarquía también fue un aspecto desafiante, ya que un prefab podía tener hijos. Implementé un sistema para que las entidades 
padre afectaran el transform de sus hijos, lo que facilitó la interacción entre ellos en la escena, como el movimiento conjunto de las entidades al mover el padre. Además, para gestionar los prefabs, 
creé una ventana llamada PrefabManager desde la cual se podían ver y editar los prefabs.

\medskip

Finalmente, junto con el equipo, nos esforzamos en mejorar el editor y corregir sus errores. Para poner a prueba nuestro trabajo, desarrollé una versión básica del juego Space Invaders en nuestro propio
editor, identificando y resolviendo numerosos errores en el proceso.
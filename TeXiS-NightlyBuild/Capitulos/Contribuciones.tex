%---------------------------------------------------------------------
%
%                          Contribuciones
%
%---------------------------------------------------------------------

\chapter{Contribuciones}

Como se comentó en el plan de trabajo, este TFG esta divido en tres partes fundamentales. Debido a que la carga
de trabajo de cada parte es similar, hemos asignado una parte a cada integrante del grupo. A pesar de esta división,
sobretodo durante la recta final del trabajo, se han dado contribuciones de todos los integrantes en cada una de las
tres partes, aunque eso sí, en menor medida.

%-------------------------------------------------------------------
\section{Pablo Fernández Álvarez}
%-------------------------------------------------------------------

Yo me he encargado de la parte del motor. Al principio me dediqué a investigar posibles librerías tanto de físicas
como de audio, para integrar al motor. En cuanto a librería de gráficos tuvimos claro desde el principio que íbamos
a usar SDL, debido a que la hemos usado bastante durante el grado y estamos acostumbrados, además de que no tiene
ninguna limitación para el desarrollo de videojuegos 2D. 

Una vez escogidas la librerías, Box2D como motor de física y SDLMixer como motor de audio, comencé a montar el proyecto
usando Visual Studio 2022. Organicé la solución en varios proyectos, física, audio, input, render, y fui implementando
cada uno de ellos. Empecé con el proyecto de Input, el cuál me llevó algo de tiempo ya que implementé soporte para teclado,
mando y múltiples mandos. Una vez terminado, fue el turno del proyecto de sonido/audio. Con la ayuda de la documentación
de SDLMixer, implementé soporte para la reproducción de efectos de sonido/sonidos cortos y música. Posteriormente comencé
con el proyecto de físicas. En este caso tuve que dedicar bastante más tiempo a aprender sobre la librería, leer artículos
y documentación, ya que es más compleja. Investigué también la opción de poder visualizar los colisionadores de los cuerpos
físicos ya que supondría una gran ayuda tanto para el desarrollo del motor como para el usuario. En la documentación de Box2D
encontré algunos ejemplos pero usaban el OpenGL para el dibujado y el motor usa SDL por lo que tuve que implementar esas
funciones de dibujado con SDL.

Luego llegó el momento de implementar el proyecto del ECS (Entity-Component-System), fundamental para realizar pruebas y 
visualizar las primeras escenas. Para ello además, implementé el bucle principal del motor con un intervalo de tiempo
fijo para el mundo físico. En este momento, con los proyectos principales implmentados, comencé a implementar los primeros
componentes básicos, como son el Transform, Image, PhyiscBody y SoundEmitter.

Durante un tiempo simplemente me dediqué a ampliar y probar los componentes y la funcionalidad implementada en los proyectos.
Por ejemplo, añadí una matriz de colisiones al proyecto de físicas para manejar el filtrado de colisiones, implementé distintos
tipos de PhyiscBody (colisionadores con formas especiales), sincronicé los cuerpos físicos con las transformaciones de la entidad,
detección de colisiones, conversión de píxeles a unidades físicas, nuevo componente ParticleSystem para sistemas de partículas, 
implementé un gestor de recursos para evitar cargar recursos duplicados, mejoré los componentes de sonido para añadir paneo 
horizontal y sonido 2D, entre otros. 

Con la parte del editor más avanzada, implementé la lógica necesaria para leer los datos que genera el editor, como
escenas o prefabs. Además, implementé la ventana de gestión de proyectos del editor, añadí control de errores en todo el motor, 
para conseguir una ejecución continua y esperable, imprimiendo los errores por la salida estándar. Añadí también control de 
errores en el editor, a través de un fichero de log, con la información de los errores durante la ejecución. Creé una estructura
de directorios para el editor y motor haciendo más cómodo el ciclo de desarrollo. Implementé una ventana de preferencias donde
ajustar parámetros del motor, como gravedad del mundo físico, frecuencia del motor de audio, tamaño de la ventana de juego, entre
muchos otros. Implementé el flujo de escenas, es decir, guardar la última escena abierta, mostrar el viewport de una forma especial
en caso de que no haya ninguna escena abierta y mostrar en el viewport el nombre de la escena actual junto con su contenido
correspondiente. 

Por último, cambié el uso que se hacía de SDL para la implementación de mando en el Input, de SDLJoystick a SDLGameController ya
que está más preparada para mando y SDLJoystick es una interfaz de más bajo nivel preparada para cualquier tipo de dispositivo.
Añadí más parámetros a la ventana de preferencias, sobretodo para Input, bindeo de teclas rápidas. He mejorado también la ventana
de gestión de proyectos para poder eliminar proyectos y ordenar los proyectos por orden de última apertura.



%-------------------------------------------------------------------
\section{Yojhan García Peña}
%-------------------------------------------------------------------

Contribuciones de Yojhan García Peña

%-------------------------------------------------------------------
\section{Iván Sánchez Míguez}
%-------------------------------------------------------------------

Mi principal responsabilidad en el proyecto se enfocó en el desarrollo del editor. En una fase inicial, mi tarea consistió en llevar a cabo una investigación exhaustiva de proyectos similares para comprender 
las bibliotecas gráficas utilizadas y evaluar si alguna de ellas podría simplificar nuestro trabajo. Después de un análisis minucioso, llegué a la conclusión de que IMGUI era la elección ideal debido a su 
amplio conjunto de funcionalidades para la interfaz de usuario (UI).

\medskip

Una vez seleccionada esta biblioteca, procedí a crear el proyecto en Visual Studio 2022. Inicié con la creación de un programa simple inicial para comprender cómo se inicializa y funciona IMGUI, el cual incluía 
un proyecto con numerosos ejemplos. Mi enfoque inicial se centró en el diseño de las ventanas principales, como la barra de menú, la jerarquía, la escena, los componentes y el explorador de archivos.
Esto se hizo de manera rápida y provisional con el único propósito de familiarizarme rápidamente con IMGUI. Durante este proceso, descubrí la rama 'imgui dock' de IMGUI, que permitía el anclaje de ventanas entre 
sí, lo que resultó ser una característica valiosa para el proyecto.

\medskip

Posteriormente, reestructuré dicho código para lograr una organización más intuitiva de las ventanas y facilitar la adición de nuevas ventanas. Para ello, cree la clase Window, que es la clase padre de cada 
ventana y se encarga de incluir la funcionalidad básica de una ventana de IMGUI. Avanzando en el proyecto, me concentré en la creación de la escena, un proceso que inicialmente resultó un tanto complicado 
debido a la complejidad en la programación, especialmente en lo que respecta al manejo de texturas y su renderización con IMGUI. Sin embargo, con el tiempo, logré comprender estos aspectos y refactorizar 
el código para obtener una forma más sencilla de renderizar la escena y sus entidades.

\medskip

Con la escena en funcionamiento, me dediqué a trabajar en la creación de entidades y su representación en la textura. Para ello, creé la clase Entidad, encargada de gestionar su textura y almacenar información 
sobre su Transform, además de asignar un ID único a cada entidad para diferenciarlas entre sí. Luego, me enfoqué en la gestión de estas entidades a través de la ventana de jerarquía, incorporando un listado 
con textos seleccionables mediante IMGUI, lo que permitió la selección de entidades. Esto también tuvo un impacto en otras ventanas, como la de componentes, que mostraba información sobre la entidad seleccionada. 
Inicialmente, la ventana de componentes mostraba solo la información del transform con entradas de IMGUI para modificar sus valores. Finalmente, desarrollé la ventana del explorador de archivos, que aunque 
al principio no la consideré esencial, resultó importante para la visualización de los activos del proyecto y la navegación entre directorios.

\medskip

Una vez que logramos tener una versión básica del editor, trabajé en su integración con el motor del proyecto. Esto implicó la serialización de escenas, entidades y sus transformaciones en formato JSON.
Posteriormente, tuve que adaptar el proceso de serialización para que fuera compatible con el motor, ya que este tenía formas distintas de leer los componentes disponibles, sus atributos y el tipo de sus atributos. 
Una vez incorporados los componentes del motor en el editor, me centré en el renderizado y la edición de estos, de modo que cada tipo de atributo tuviera su propia representación en la ventana de componentes, 
lo que se logró de manera eficiente gracias a IMGUI. También permití la adición de dichos componentes a las entidades.

\medskip

Posteriormente, me dediqué a la implementación de funciones más avanzadas, como el uso de prefabs y la gestión de la jerarquía entre entidades. Esto fue un desafío significativo, ya que implicaba rehacer el 
sistema de asignación de IDs para que los prefabs tuvieran IDs negativos y estuvieran referenciados en todas sus instancias. Además, fue necesario tener en cuenta este sistema de IDs en múltiples partes del 
código para evitar conflictos con el uso normal de las entidades. La gestión de la jerarquía también presentó complejidades, ya que cada entidad contenía referencias a su padre y sus hijos, lo que debía 
considerarse en numerosas partes del código. La interacción entre prefabs y la jerarquía también fue un aspecto desafiante, ya que un prefab podía tener hijos. Implementé un sistema para que las entidades 
padre afectaran el transform de sus hijos, lo que facilitó la interacción entre ellos en la escena, como el movimiento conjunto de las entidades al mover el padre. Además, para gestionar los prefabs, 
creé una ventana llamada PrefabManager desde la cual se podían ver y editar los prefabs.

\medskip

Finalmente, junto con el equipo, nos esforzamos en mejorar el editor y corregir sus errores. Para poner a prueba nuestro trabajo, desarrollé una versión básica del juego Space Invaders en nuestro propio
editor, identificando y resolviendo numerosos errores en el proceso.